service: flowlogic-backend-staging-v2
# Временно изменено для обхода DELETE_FAILED stack
# TODO: Вернуть обратно после успешного деплоя
# service: flowlogic-backend

frameworkVersion: '4'  # Serverless Framework v4 with built-in esbuild

provider:
  name: aws
  runtime: nodejs20.x
  architecture: arm64
  region: ${opt:region, 'us-east-1'}
  stage: ${opt:stage, 'dev'}
  memorySize: 512
  timeout: 30
  logRetentionInDays: 7
  tracing:
    lambda: true
  # Explicit deployment bucket to avoid SSM Parameter Store requirement
  # Serverless Framework v4 tries to use SSM for bucket info, but we don't have SSM permissions
  deploymentBucket:
    name: flowlogic-${self:provider.stage}-serverless-deployment
    blockPublicAccess: true
    versioning: true
  environment:
    STAGE: ${self:provider.stage}
    NODE_ENV: ${self:custom.nodeEnv.${self:provider.stage}, self:custom.nodeEnv.prod}
    # Временно удаляем SSM параметры для обхода ResourceExistenceCheck
    # Загружаем в runtime через AWS SDK в Lambda функциях
    # COGNITO_USER_POOL_ID: ${ssm:/flowlogic/${self:provider.stage}/cognito/user-pool-id}
    # COGNITO_CLIENT_ID: ${ssm:/flowlogic/${self:provider.stage}/cognito/client-id}
    COGNITO_USER_POOL_ID: 'PLACEHOLDER_LOAD_IN_RUNTIME'
    COGNITO_CLIENT_ID: 'PLACEHOLDER_LOAD_IN_RUNTIME'
    DYNAMODB_USERS_TABLE: ${self:custom.tables.users}
    DYNAMODB_SUBSCRIPTIONS_TABLE: ${self:custom.tables.subscriptions}
    DYNAMODB_ASSESSMENTS_TABLE: ${self:custom.tables.assessments}
    DYNAMODB_PLANS_TABLE: ${self:custom.tables.plans}
    DYNAMODB_CALENDAR_TASKS_TABLE: ${self:custom.tables.calendarTasks}
    DYNAMODB_PROGRESS_TABLE: ${self:custom.tables.progress}
    DYNAMODB_USER_LIMITS_TABLE: ${self:custom.tables.userLimits}
    DYNAMODB_MIGRATIONS_TABLE: ${self:custom.tables.migrations}
    S3_BUCKET: ${self:custom.s3.bucket}
    # Временно удаляем SSM параметр для обхода ResourceExistenceCheck
    # Загружаем в runtime через AWS SDK
    # STRIPE_SECRET_KEY: ${ssm:/flowlogic/${self:provider.stage}/stripe/secret-key, true}
    STRIPE_SECRET_KEY: 'PLACEHOLDER_LOAD_IN_RUNTIME'
    FRONTEND_URL: ${self:custom.frontendUrl.${self:provider.stage}, self:custom.frontendUrl.prod}
    ALLOWED_ORIGINS: 'https://flowlogic.shop,https://frontend-mu-six-96.vercel.app'
  iam:
    role:
      statements:
        - Effect: Allow
          Action:
            - dynamodb:Query
            - dynamodb:Scan
            - dynamodb:GetItem
            - dynamodb:PutItem
            - dynamodb:UpdateItem
            - dynamodb:DeleteItem
          Resource:
            # Возвращаем wildcard patterns (гипотеза K отклонена)
            # Проблема в SSM параметрах в environment variables, не в IAM policy
            - arn:aws:dynamodb:${self:provider.region}:*:table/${self:custom.tables.users}
            - arn:aws:dynamodb:${self:provider.region}:*:table/${self:custom.tables.subscriptions}
            - arn:aws:dynamodb:${self:provider.region}:*:table/${self:custom.tables.assessments}
            - arn:aws:dynamodb:${self:provider.region}:*:table/${self:custom.tables.plans}
            - arn:aws:dynamodb:${self:provider.region}:*:table/${self:custom.tables.calendarTasks}
            - arn:aws:dynamodb:${self:provider.region}:*:table/${self:custom.tables.progress}
            - arn:aws:dynamodb:${self:provider.region}:*:table/${self:custom.tables.userLimits}
            - arn:aws:dynamodb:${self:provider.region}:*:table/${self:custom.tables.migrations}
            - arn:aws:dynamodb:${self:provider.region}:*:table/${self:custom.tables.users}/index/*
            - arn:aws:dynamodb:${self:provider.region}:*:table/${self:custom.tables.subscriptions}/index/*
            - arn:aws:dynamodb:${self:provider.region}:*:table/${self:custom.tables.assessments}/index/*
            - arn:aws:dynamodb:${self:provider.region}:*:table/${self:custom.tables.plans}/index/*
            - arn:aws:dynamodb:${self:provider.region}:*:table/${self:custom.tables.calendarTasks}/index/*
            - arn:aws:dynamodb:${self:provider.region}:*:table/${self:custom.tables.progress}/index/*
        - Effect: Allow
          Action:
            - s3:GetObject
            - s3:PutObject
            - s3:DeleteObject
            - s3:GetObjectPresignedUrl
          Resource:
            - arn:aws:s3:::${self:custom.s3.bucket}/*
        - Effect: Allow
          Action:
            - cognito-idp:AdminCreateUser
            - cognito-idp:AdminGetUser
            - cognito-idp:AdminUpdateUserAttributes
            - cognito-idp:AdminDeleteUser
            - cognito-idp:AdminConfirmSignUp
            - cognito-idp:ListUsers
          Resource:
            # Используем wildcard вместо конкретного User Pool ID для обхода ResourceExistenceCheck
            # TODO: Вернуть конкретный ARN после успешного деплоя, если ResourceExistenceCheck будет работать
            - arn:aws:cognito-idp:${self:provider.region}:*:userpool/*
        - Effect: Allow
          Action:
            - logs:CreateLogGroup
            - logs:CreateLogStream
            - logs:PutLogEvents
          Resource: '*'
        # Временно отключено из-за ResourceExistenceCheck ошибки
        # TODO: Включить обратно после успешного деплоя
        # - Effect: Allow
        #   Action:
        #     - sqs:SendMessage
        #     - sqs:GetQueueAttributes
        #   Resource:
        #     - !GetAtt ProcessingDLQ.Arn

custom:
  nodeEnv:
    dev: development
    staging: staging
    production: production
    prod: production  # Alias for production
  tables:
    users: flowlogic-${self:provider.stage}-users
    subscriptions: flowlogic-${self:provider.stage}-subscriptions
    assessments: flowlogic-${self:provider.stage}-assessments
    plans: flowlogic-${self:provider.stage}-plans
    calendarTasks: flowlogic-${self:provider.stage}-calendar-tasks
    progress: flowlogic-${self:provider.stage}-progress
    userLimits: flowlogic-${self:provider.stage}-user-limits
    migrations: flowlogic-${self:provider.stage}-migrations
  s3:
    bucket: flowlogic-${self:provider.stage}-videos
  frontendUrl:
    dev: http://localhost:3000
    staging: https://staging.flowlogic.shop
    production: https://flowlogic.shop
    prod: https://flowlogic.shop  # Alias for production

functions:
  api:
    handler: src/backend/dist/index.handler
    # Dead Letter Queue для failed invocations
    # В Serverless Framework v4 используется onError вместо deadLetter
    # Временно отключено из-за ResourceExistenceCheck ошибки
    # TODO: Включить обратно после успешного деплоя
    # onError: !GetAtt ProcessingDLQ.Arn
    events:
      - http:
          path: /{proxy+}
          method: ANY
          # CORS полностью обрабатывается Express middleware
          # Не настраиваем CORS в API Gateway, чтобы все запросы (включая OPTIONS) проходили через Lambda
      - http:
          path: /
          method: ANY
          # CORS полностью обрабатывается Express middleware
          # Не настраиваем CORS в API Gateway, чтобы все запросы (включая OPTIONS) проходили через Lambda

resources:
  # Временно отключено из-за ResourceExistenceCheck ошибки
  # TODO: Включить обратно после успешного деплоя
  # - ${file(monitoring.yml)}
  # Импорт основных ресурсов (DLQ, DynamoDB tables, S3)
  - ${file(resources.yml)}
