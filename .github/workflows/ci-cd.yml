# CI/CD Pipeline –¥–ª—è Flow Logic
# –ò—Å–ø–æ–ª—å–∑—É–µ—Ç GitHub Personal Access Token –¥–ª—è —Ä–∞–±–æ—Ç—ã –∞–≥–µ–Ω—Ç–æ–≤

name: CI/CD Pipeline

on:
  push:
    branches:
      - main
      - develop
  pull_request:
    branches:
      - main
      - develop
  workflow_dispatch:

jobs:
  build:
    name: Build and Test
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # –ü–æ–ª–Ω–∞—è –∏—Å—Ç–æ—Ä–∏—è –¥–ª—è –∞–≥–µ–Ω—Ç–æ–≤
        
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'  # Updated from '20' (Node.js 20.x deprecated in Lambda 2026-04-30)
          # –ù–µ –∏—Å–ø–æ–ª—å–∑—É–µ–º cache, —Ç–∞–∫ –∫–∞–∫ package-lock.json –≤ –ø–æ–¥–¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è—Ö
      
      - name: Check project structure
        run: |
          echo "üìÅ Project structure:"
          ls -la src/ 2>/dev/null || echo "‚ö†Ô∏è  src/ directory not found"
          echo ""
          echo "Backend:"
          ls -la src/backend/ 2>/dev/null | head -5 || echo "‚ö†Ô∏è  src/backend/ not found"
          echo ""
          echo "Frontend:"
          ls -la src/frontend/ 2>/dev/null | head -5 || echo "‚ö†Ô∏è  src/frontend/ not found"
      
      - name: Install dependencies (Backend)
        run: |
          if [ -f "src/backend/package.json" ]; then
            echo "üì¶ Installing backend dependencies..."
            cd src/backend
            if [ -f "package-lock.json" ]; then
              npm ci || {
                echo "‚ö†Ô∏è  npm ci failed, trying npm install..."
                npm install
              }
            else
              echo "‚ö†Ô∏è  package-lock.json not found, using npm install"
              npm install
            fi
            echo "‚úÖ Backend dependencies installed"
          else
            echo "‚ö†Ô∏è  Backend package.json not found, skipping..."
          fi
      
      - name: Install dependencies (Frontend)
        run: |
          if [ -f "src/frontend/package.json" ]; then
            echo "üì¶ Installing frontend dependencies..."
            cd src/frontend
            if [ -f "package-lock.json" ]; then
              npm ci || {
                echo "‚ö†Ô∏è  npm ci failed, trying npm install..."
                npm install
              }
            else
              echo "‚ö†Ô∏è  package-lock.json not found, using npm install"
              npm install
            fi
            echo "‚úÖ Frontend dependencies installed"
          else
            echo "‚ö†Ô∏è  Frontend package.json not found, skipping..."
          fi
      
      - name: Build Backend
        run: |
          if [ -f "src/backend/package.json" ] && [ -f "src/backend/tsconfig.json" ]; then
            echo "üì¶ Building backend..."
            echo "üìÅ Current directory: $(pwd)"
            echo "üìÅ Checking config files:"
            ls -la src/backend/config/*.ts || echo "‚ö†Ô∏è  Config files not found"
            cd src/backend
            echo "üìÅ In backend directory: $(pwd)"
            echo "üìÅ Config files here:"
            ls -la config/*.ts || echo "‚ö†Ô∏è  Config files not found in backend/"
            npm run build || {
              echo "‚ùå Backend build failed"
              exit 1
            }
            echo "‚úÖ Backend build successful"
          else
            echo "‚ö†Ô∏è  Backend not found or not configured, skipping build..."
          fi
      
      - name: Build Frontend
        run: |
          if [ -f "src/frontend/package.json" ]; then
            echo "üì¶ Building frontend..."
            cd src/frontend
            npm run build || {
              echo "‚ùå Frontend build failed"
              exit 1
            }
            echo "‚úÖ Frontend build successful"
          else
            echo "‚ö†Ô∏è  Frontend not found or not configured, skipping build..."
          fi
        env:
          VITE_API_URL: ${{ secrets.VITE_API_URL || 'https://api.flowlogic.shop' }}
      
      - name: Run tests
        if: hashFiles('src/backend/package.json') != ''
        run: |
          cd src/backend
          npm test -- --coverage || true
        continue-on-error: true

  deploy-staging:
    name: Deploy to Staging
    needs: build
    if: github.ref == 'refs/heads/develop'
    runs-on: ubuntu-latest
    environment: staging
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
      
      - name: Deploy Backend (Serverless)
        run: |
          if [ -d "infra/serverless" ]; then
            cd infra/serverless
            echo "üì¶ Installing Serverless Framework..."
            npm install -g serverless@latest
            echo "üì¶ Installing dependencies..."
            npm install
            echo "üöÄ Deploying to staging..."
            serverless deploy --stage staging
          else
            echo "‚ö†Ô∏è  infra/serverless directory not found, skipping deployment"
          fi
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      
      - name: Deploy Frontend (Vercel)
        run: |
          cd src/frontend
          npm install -g vercel
          vercel deploy --prebuilt --prod
        env:
          VERCEL_TOKEN: ${{ secrets.VERCEL_TOKEN }}
          VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}
          VERCEL_PROJECT_ID: ${{ secrets.VERCEL_PROJECT_ID }}

  deploy-production:
    name: Deploy to Production
    needs: build
    if: github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    environment: production
    # –ï—Å–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è OIDC, –Ω—É–∂–Ω—ã permissions –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —Ç–æ–∫–µ–Ω–∞
    permissions:
      id-token: write
      contents: read
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
      
      - name: Check AWS credentials configuration
        id: check-aws-creds
        run: |
          echo "üîç Checking AWS credentials configuration..."
          
          # –ü—Ä–æ–≤–µ—Ä–∫–∞ ARN
          AWS_ROLE_ARN="${{ secrets.AWS_ROLE_ARN }}"
          if [ -n "$AWS_ROLE_ARN" ]; then
            echo "‚úÖ AWS_ROLE_ARN found"
            echo "ARN format check:"
            if [[ "$AWS_ROLE_ARN" =~ ^arn:aws:iam::[0-9]{12}:role/[a-zA-Z0-9+=,.@_-]+$ ]]; then
              echo "‚úÖ ARN format is valid"
              echo "ARN: $AWS_ROLE_ARN"
              echo "USE_OIDC=true" >> $GITHUB_OUTPUT
            else
              echo "‚ùå ARN format is INVALID!"
              echo "Expected format: arn:aws:iam::ACCOUNT_ID:role/ROLE_NAME"
              echo "Current value: $AWS_ROLE_ARN"
              echo ""
              echo "‚ö†Ô∏è  Will skip OIDC and use Access Keys instead"
              echo "USE_OIDC=false" >> $GITHUB_OUTPUT
            fi
          else
            echo "‚ö†Ô∏è  AWS_ROLE_ARN not found, will use Access Keys"
            echo "USE_OIDC=false" >> $GITHUB_OUTPUT
          fi
          
          # –ü—Ä–æ–≤–µ—Ä–∫–∞ Access Keys (–¥–ª—è production –∏—Å–ø–æ–ª—å–∑—É–µ–º _PROD —Å—É—Ñ—Ñ–∏–∫—Å)
          AWS_ACCESS_KEY_ID_VAL="${{ secrets.AWS_ACCESS_KEY_ID_PROD }}"
          AWS_SECRET_ACCESS_KEY_VAL="${{ secrets.AWS_SECRET_ACCESS_KEY_PROD }}"
          
          # Fallback –Ω–∞ –æ–±—â–∏–µ –∏–º–µ–Ω–∞ (–¥–ª—è –æ–±—Ä–∞—Ç–Ω–æ–π —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏)
          if [ -z "$AWS_ACCESS_KEY_ID_VAL" ]; then
            AWS_ACCESS_KEY_ID_VAL="${{ secrets.AWS_ACCESS_KEY_ID }}"
          fi
          if [ -z "$AWS_SECRET_ACCESS_KEY_VAL" ]; then
            AWS_SECRET_ACCESS_KEY_VAL="${{ secrets.AWS_SECRET_ACCESS_KEY }}"
          fi
          
          if [ -n "$AWS_ACCESS_KEY_ID_VAL" ] && [ -n "$AWS_SECRET_ACCESS_KEY_VAL" ]; then
            echo "‚úÖ AWS Access Keys found (using AWS_ACCESS_KEY_ID_PROD or AWS_ACCESS_KEY_ID)"
            echo "HAS_ACCESS_KEYS=true" >> $GITHUB_OUTPUT
          else
            echo "‚ö†Ô∏è  AWS Access Keys not found"
            echo "   –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –Ω–∞–ª–∏—á–∏–µ AWS_ACCESS_KEY_ID_PROD –∏–ª–∏ AWS_ACCESS_KEY_ID"
            echo "   –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –Ω–∞–ª–∏—á–∏–µ AWS_SECRET_ACCESS_KEY_PROD –∏–ª–∏ AWS_SECRET_ACCESS_KEY"
            echo "HAS_ACCESS_KEYS=false" >> $GITHUB_OUTPUT
          fi
          
          # –§–∏–Ω–∞–ª—å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ (–∏—Å–ø–æ–ª—å–∑—É–µ–º –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –≤–º–µ—Å—Ç–æ outputs –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –≤ —Ç–æ–º –∂–µ —à–∞–≥–µ)
          USE_OIDC_VAL="false"
          HAS_ACCESS_KEYS_VAL="false"
          
          if [ -n "$AWS_ROLE_ARN" ] && [[ "$AWS_ROLE_ARN" =~ ^arn:aws:iam::[0-9]{12}:role/[a-zA-Z0-9+=,.@_-]+$ ]]; then
            USE_OIDC_VAL="true"
          fi
          
          # –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ç–µ –∂–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ, —á—Ç–æ –∏ –≤—ã—à–µ
          if [ -n "$AWS_ACCESS_KEY_ID_VAL" ] && [ -n "$AWS_SECRET_ACCESS_KEY_VAL" ]; then
            HAS_ACCESS_KEYS_VAL="true"
          fi
          
          if [ "$USE_OIDC_VAL" != "true" ] && [ "$HAS_ACCESS_KEYS_VAL" != "true" ]; then
            echo "‚ùå ERROR: Neither valid AWS_ROLE_ARN nor AWS Access Keys are configured!"
            echo ""
            echo "Please configure one of the following:"
            echo "1. AWS_ROLE_ARN (for OIDC) - format: arn:aws:iam::ACCOUNT_ID:role/ROLE_NAME"
            echo "   Current value appears to be empty or invalid"
            echo "2. AWS_ACCESS_KEY_ID_PROD + AWS_SECRET_ACCESS_KEY_PROD (for Access Keys - RECOMMENDED)"
            echo "   OR AWS_ACCESS_KEY_ID + AWS_SECRET_ACCESS_KEY (fallback)"
            echo ""
            echo "See: docs/deployment/aws_oidc_setup.md or docs/deployment/aws_credentials_setup.md"
            echo ""
            echo "üìã –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–µ–∫—Ä–µ—Ç–æ–≤:"
            echo "   https://github.com/recreomassage-hub/flowlogic.shop/settings/secrets/actions"
            exit 1
          fi
          
          echo ""
          echo "üìä Configuration summary:"
          echo "   USE_OIDC: $USE_OIDC_VAL"
          echo "   HAS_ACCESS_KEYS: $HAS_ACCESS_KEYS_VAL"
      
      # Step 1: Configure OIDC (early) - for early secrets loading
      - name: Configure AWS credentials (OIDC)
        if: steps.check-aws-creds.outputs.USE_OIDC == 'true'
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: us-east-1
          role-session-name: github-${{ github.run_id }}-early
        continue-on-error: true
        id: aws-config-oidc
      
      # Step 2: Load ALL SSM Parameters Early (when OIDC token is fresh)
      - name: Load ALL SSM Parameters Early
        id: load-secrets
        if: steps.aws-config-oidc.outcome == 'success'
        run: |
          echo "üîç Loading all SSM parameters early (OIDC token is fresh)..."
          
          # List all SSM parameters needed for this workflow
          # TODO: Update this list with actual parameters used in deployment
          PARAMETERS=(
            "/flowlogic/production/database/url"
            "/flowlogic/production/api/keys"
            "/flowlogic/production/external/services"
          )
          
          # Batch read –≤—Å–µ—Ö –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ —Å—Ä–∞–∑—É
          aws ssm get-parameters \
            --names "${PARAMETERS[@]}" \
            --with-decryption \
            --query "Parameters[*].{Name:Name,Value:Value}" \
            --output json > ssm_parameters.json 2>&1 || {
              echo "‚ö†Ô∏è  Failed to read SSM parameters, will use fallback"
              echo "{}" > ssm_parameters.json
            }
          
          # Save to GitHub Actions environment
          echo "SSM_PARAMETERS=$(cat ssm_parameters.json | jq -c .)" >> $GITHUB_ENV
          
          # Verify parameters loaded
          PARAM_COUNT=$(cat ssm_parameters.json | jq '. | length' || echo "0")
          echo "‚úÖ Loaded $PARAM_COUNT SSM parameters"
          
          # Send metric to CloudWatch (workflow start)
          if [ -f "scripts/send-oidc-metrics.sh" ]; then
            ./scripts/send-oidc-metrics.sh WorkflowDuration 0 Seconds || true
          fi
      
      # Step 3: Cache SSM Parameters
      - name: Cache SSM Parameters
        if: steps.load-secrets.outcome == 'success'
        uses: actions/cache/save@v3
        with:
          path: ssm_parameters.json
          key: ssm-params-${{ github.sha }}
          fail-on-cache-miss: false
      
      # Step 4: Fallback to Access Keys if OIDC failed
      - name: Configure AWS credentials (Access Keys Fallback)
        # Prefer Access Keys for SSM Parameter Store access (more reliable than OIDC)
        if: steps.check-aws-creds.outputs.HAS_ACCESS_KEYS == 'true' && steps.aws-config-oidc.outcome != 'success'
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID_PROD != '' && secrets.AWS_ACCESS_KEY_ID_PROD || secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY_PROD != '' && secrets.AWS_SECRET_ACCESS_KEY_PROD || secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1
        id: aws-config-keys
      
      # Step 5: Load secrets with Access Keys fallback
      - name: Load SSM Parameters (Fallback)
        if: steps.aws-config-oidc.outcome != 'success' && steps.aws-config-keys.outcome == 'success'
        run: |
          echo "‚ö†Ô∏è  Using Access Keys fallback for SSM access"
          
          PARAMETERS=(
            "/flowlogic/production/database/url"
            "/flowlogic/production/api/keys"
            "/flowlogic/production/external/services"
          )
          
          aws ssm get-parameters \
            --names "${PARAMETERS[@]}" \
            --with-decryption \
            --query "Parameters[*].{Name:Name,Value:Value}" \
            --output json > ssm_parameters.json || {
              echo "‚ùå Failed to read SSM parameters with Access Keys"
              exit 1
            }
          
          echo "SSM_PARAMETERS=$(cat ssm_parameters.json | jq -c .)" >> $GITHUB_ENV
          
          # Send fallback usage metric
          if [ -f "scripts/send-oidc-metrics.sh" ]; then
            ./scripts/send-oidc-metrics.sh SSMFallbackUsage 1 Count || true
          fi
      
      # Step 6: Verify secrets loaded
      - name: Verify secrets loaded
        if: steps.load-secrets.outcome == 'success' || steps.aws-config-keys.outcome == 'success'
        run: |
          if [ -z "${SSM_PARAMETERS:-}" ] || [ "$SSM_PARAMETERS" = "{}" ]; then
            echo "‚ö†Ô∏è  WARNING: SSM parameters not loaded (may not be needed for this workflow)"
          else
            echo "‚úÖ SSM parameters loaded successfully"
            PARAM_COUNT=$(echo "$SSM_PARAMETERS" | jq '. | length' || echo "0")
            echo "   Parameters count: $PARAM_COUNT"
          fi
      
      - name: Verify AWS credentials
        run: |
          echo "üîç Verifying AWS credentials..."
          # Prefer Access Keys for SSM access (more reliable)
          if [ "${{ steps.aws-config-keys.outcome }}" == "success" ]; then
            echo "‚úÖ Using Access Keys for AWS authentication (preferred for SSM access)"
          elif [ "${{ steps.aws-config-oidc.outcome }}" == "success" ]; then
            echo "‚ö†Ô∏è  Using OIDC for AWS authentication (may have SSM access issues)"
          fi
          if [ "${{ steps.aws-config-oidc.outcome }}" == "success" ] || [ "${{ steps.aws-config-keys.outcome }}" == "success" ]; then
            aws sts get-caller-identity || {
              echo ""
              echo "‚ùå Failed to authenticate with AWS!"
              exit 1
            }
            echo "‚úÖ AWS authentication successful"
            aws sts get-caller-identity
          else
            echo ""
            echo "‚ùå Failed to configure AWS credentials!"
            echo ""
            if [ "${{ steps.check-aws-creds.outputs.USE_OIDC }}" == "true" ]; then
              echo "üîç OIDC Configuration Issue:"
              echo "   ARN: ${{ secrets.AWS_ROLE_ARN }}"
              echo ""
              echo "üìã –ü–†–û–í–ï–†–¨–¢–ï:"
              echo "   1. ARN —Ñ–æ—Ä–º–∞—Ç –ø—Ä–∞–≤–∏–ª—å–Ω—ã–π: arn:aws:iam::ACCOUNT_ID:role/ROLE_NAME"
              echo "   2. –†–æ–ª—å —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –≤ AWS"
              echo "   3. OIDC Provider —Å–æ–∑–¥–∞–Ω"
              echo "   4. Trust Policy –Ω–∞—Å—Ç—Ä–æ–µ–Ω –¥–ª—è OIDC"
              echo ""
              echo "üí° –†–ï–®–ï–ù–ò–ï: –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ Access Keys"
              echo "   1. –î–æ–±–∞–≤—å—Ç–µ AWS_ACCESS_KEY_ID –∏ AWS_SECRET_ACCESS_KEY"
              echo "   2. –£–¥–∞–ª–∏—Ç–µ –∏–ª–∏ –æ—Å—Ç–∞–≤—å—Ç–µ –ø—É—Å—Ç—ã–º AWS_ROLE_ARN"
              echo ""
              echo "üìö Troubleshooting: docs/deployment/troubleshooting/aws_credentials.md"
            else
              echo "üîç Access Keys Configuration Issue:"
              echo ""
              echo "üìã –ü–†–û–í–ï–†–¨–¢–ï:"
              echo "   1. AWS_ACCESS_KEY_ID_PROD –¥–æ–±–∞–≤–ª–µ–Ω –≤ GitHub Secrets (–∏–ª–∏ AWS_ACCESS_KEY_ID)"
              echo "   2. AWS_SECRET_ACCESS_KEY_PROD –¥–æ–±–∞–≤–ª–µ–Ω –≤ GitHub Secrets (–∏–ª–∏ AWS_SECRET_ACCESS_KEY)"
              echo "   3. Access Keys –∞–∫—Ç–∏–≤–Ω—ã –≤ AWS"
              echo ""
              echo "üìö –ò–Ω—Å—Ç—Ä—É–∫—Ü–∏—è: docs/deployment/aws_credentials_setup.md"
            fi
            echo ""
            echo "üîó –ù–∞—Å—Ç—Ä–æ–π–∫–∞ Secrets:"
            echo "   https://github.com/recreomassage-hub/flowlogic.shop/settings/secrets/actions"
            echo ""
            exit 1
          fi
      
      - name: Deploy Backend (Serverless)
        run: |
          if [ -d "infra/serverless" ]; then
            cd infra/serverless
            echo "üì¶ Installing Serverless Framework..."
            npm install -g serverless@latest || {
              echo "‚ö†Ô∏è  Failed to install serverless globally, trying local install..."
              npm install serverless --save-dev
            }
            echo "üì¶ Installing dependencies..."
            npm install
            echo "üìÅ Current directory: $(pwd)"
            echo "üìÅ Checking serverless.yml..."
            if [ -f "serverless.yml" ]; then
              echo "‚úÖ serverless.yml found"
            else
              echo "‚ùå serverless.yml not found!"
              exit 1
            fi
            echo "üîç Validating serverless.yml configuration..."
            npx serverless print --stage production || {
              echo "‚ùå Serverless configuration validation failed"
              exit 1
            }
            echo "üöÄ Deploying to production..."
            npx serverless deploy --stage production || {
              echo "‚ùå Deployment failed"
              exit 1
            }
          else
            echo "‚ö†Ô∏è  infra/serverless directory not found, skipping deployment"
          fi
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID_PROD != '' && secrets.AWS_ACCESS_KEY_ID_PROD || secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY_PROD != '' && secrets.AWS_SECRET_ACCESS_KEY_PROD || secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_DEFAULT_REGION: us-east-1
          AWS_REGION: us-east-1
      
      - name: Deploy Frontend (Vercel)
        run: |
          cd src/frontend
          npm install -g vercel
          vercel deploy --prod --token ${{ secrets.VERCEL_TOKEN }} --yes
        env:
          VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}
          VERCEL_PROJECT_ID: ${{ secrets.VERCEL_PROJECT_ID }}

  agent-workflow:
    name: Agent Workflow (GitHub API)
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_dispatch' || contains(github.event.head_commit.message, '[AGENT]')
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Setup Python (–¥–ª—è –∞–≥–µ–Ω—Ç–æ–≤)
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
      
      - name: Install dependencies
        run: |
          pip install PyGithub
      
      - name: Use GitHub token for GitHub API calls
        env:
          # –ü–æ–¥–¥–µ—Ä–∂–∫–∞ –æ–±–æ–∏—Ö –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤ –∏–º–µ–Ω–∏ —Å–µ–∫—Ä–µ—Ç–∞
          GITHUB_TOKEN: ${{ secrets.MY_GITHUB_TOKEN || secrets.GITHUB_TOKEN }}
        run: |
          echo "‚úÖ Using GitHub token for authentication"
          echo "Token format: ${GITHUB_TOKEN:0:7}...${GITHUB_TOKEN: -4}"
          
          # –¢–µ—Å—Ç –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ GitHub API
          python3 << 'EOF'
          import os
          from github import Github
          
          token = os.getenv('GITHUB_TOKEN')
          if not token:
              print("‚ùå GITHUB_TOKEN not set")
              exit(1)
          
          try:
              g = Github(token)
              user = g.get_user()
              print(f"‚úÖ Connected to GitHub as: {user.login}")
              
              # –ü–æ–ª—É—á–µ–Ω–∏–µ —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏—è
              repo = g.get_repo("recreomassage-hub/flowlogic.shop")
              print(f"‚úÖ Repository: {repo.full_name}")
              print(f"   Description: {repo.description or 'N/A'}")
              print(f"   Status: {'Private' if repo.private else 'Public'}")
              
              # –ü–æ–ª—É—á–µ–Ω–∏–µ –ø–æ—Å–ª–µ–¥–Ω–∏—Ö –∫–æ–º–º–∏—Ç–æ–≤
              commits = list(repo.get_commits()[:5])
              print(f"\nüìù Last 5 commits:")
              for commit in commits:
                  msg = commit.commit.message.split('\n')[0]
                  print(f"   - {commit.sha[:7]}: {msg}")
              
          except Exception as e:
              print(f"‚ùå Error: {e}")
              exit(1)
          EOF
      
      - name: Agent operations
        env:
          # –ü–æ–¥–¥–µ—Ä–∂–∫–∞ –æ–±–æ–∏—Ö –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤ –∏–º–µ–Ω–∏ —Å–µ–∫—Ä–µ—Ç–∞
          GITHUB_TOKEN: ${{ secrets.MY_GITHUB_TOKEN || secrets.GITHUB_TOKEN }}
          GITHUB_REPO: recreomassage-hub/flowlogic.shop
        run: |
          echo "ü§ñ Agent operations can use GITHUB_TOKEN here"
          # –ü—Ä–∏–º–µ—Ä: —Å–æ–∑–¥–∞–Ω–∏–µ issue, –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–µ–≤, –ø—Ä–æ–≤–µ—Ä–∫–∞ PR –∏ —Ç.–¥.

