name: Backend Deployment

on:
  push:
    branches:
      - develop
      - main
    paths:
      - 'src/backend/**'
      - 'infra/serverless/**'
      - '.github/workflows/backend-deploy.yml'
  workflow_dispatch:
    inputs:
      stage:
        description: 'Deployment stage'
        required: true
        type: choice
        options:
          - dev
          - staging
          - production

jobs:
  deploy-dev:
    if: github.ref == 'refs/heads/develop' || (github.event_name == 'workflow_dispatch' && github.event.inputs.stage == 'dev')
    name: Deploy to Dev
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
    environment:
      name: dev
      url: https://t1p7ii26f5.execute-api.us-east-1.amazonaws.com/dev/
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'
          cache: 'npm'
          cache-dependency-path: infra/serverless/package-lock.json

      - name: Install Serverless Framework
        run: npm install -g serverless@4
      
      - name: Configure Serverless Framework Access Key
        env:
          SERVERLESS_ACCESS_KEY: ${{ secrets.SERVERLESS_ACCESS_KEY }}
        run: |
          if [ -n "$SERVERLESS_ACCESS_KEY" ]; then
            echo "‚úÖ Serverless Framework Access Key found"
            export SERVERLESS_ACCESS_KEY
          else
            echo "‚ö†Ô∏è  SERVERLESS_ACCESS_KEY not found in secrets"
            echo "   Serverless Framework v4 requires an access key"
            exit 1
          fi

      - name: Install dependencies
        working-directory: infra/serverless
        run: npm ci

      - name: Build TypeScript backend
        working-directory: src/backend
        run: npm ci && npm run build

      # Step 1: Check AWS credentials configuration
      - name: Check AWS credentials configuration
        id: check-aws-creds
        run: |
          USE_OIDC="false"
          HAS_ACCESS_KEYS="false"
          
          if [ -n "${{ secrets.AWS_ROLE_ARN }}" ]; then
            USE_OIDC="true"
            echo "‚úÖ AWS_ROLE_ARN found in GitHub Environment"
          else
            echo "‚ö†Ô∏è  AWS_ROLE_ARN not found in GitHub Environment"
          fi
          
          if [ -n "${{ secrets.AWS_ACCESS_KEY_ID_DEV }}" ] && [ -n "${{ secrets.AWS_SECRET_ACCESS_KEY_DEV }}" ]; then
            HAS_ACCESS_KEYS="true"
            echo "‚úÖ Access Keys found (for fallback)"
          fi
          
          echo "USE_OIDC=$USE_OIDC" >> $GITHUB_OUTPUT
          echo "HAS_ACCESS_KEYS=$HAS_ACCESS_KEYS" >> $GITHUB_OUTPUT
          
          if [ "$USE_OIDC" != "true" ] && [ "$HAS_ACCESS_KEYS" != "true" ]; then
            echo "‚ùå ERROR: Neither AWS_ROLE_ARN nor Access Keys are configured!"
            exit 1
          fi

      # Step 2: Configure OIDC
      - name: Configure AWS credentials (OIDC)
        if: steps.check-aws-creds.outputs.USE_OIDC == 'true'
        uses: aws-actions/configure-aws-credentials@v5
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: us-east-1
          role-session-name: github-${{ github.run_id }}-dev
        continue-on-error: true
        id: aws-config-oidc

      # Step 3: Validate AWS credentials
      - name: Validate AWS credentials
        if: steps.aws-config-oidc.outcome == 'success'
        env:
          AWS_ROLE_ARN: ${{ secrets.AWS_ROLE_ARN }}
          ENVIRONMENT: dev
        run: |
          if [ -f "scripts/validate-aws-credentials.sh" ]; then
            ./scripts/validate-aws-credentials.sh dev
          fi

      # Step 3.5: Load SSM Parameters Early (when OIDC token is fresh)
      - name: Load SSM Parameters Early
        if: steps.aws-config-oidc.outcome == 'success'
        id: load-ssm-params
        run: |
          echo "üîç Loading SSM parameters early (OIDC token is fresh)..."
          
          # Read first OIDC deployment date from SSM Parameter Store
          FIRST_OIDC_DATE=$(aws ssm get-parameter \
            --name "/flowlogic/cicd/first-oidc-deployment-date" \
            --query "Parameter.Value" \
            --output text 2>/dev/null || echo "")
          
          if [ -n "$FIRST_OIDC_DATE" ]; then
            echo "‚úÖ First OIDC date loaded: $FIRST_OIDC_DATE"
            echo "FIRST_OIDC_DATE=$FIRST_OIDC_DATE" >> $GITHUB_ENV
          else
            echo "‚ö†Ô∏è  First OIDC date not found in SSM Parameter Store"
            echo "FIRST_OIDC_DATE=" >> $GITHUB_ENV
          fi
          
          # Load any other SSM parameters needed for deployment
          # Add more parameters here as needed
          echo "‚úÖ SSM parameters loaded successfully"

      # Step 4: Check fallback expiry (if OIDC failed)
      - name: Check fallback expiry
        if: steps.aws-config-oidc.outcome != 'success' && steps.check-aws-creds.outputs.HAS_ACCESS_KEYS == 'true'
        id: check-fallback-expiry
        run: |
          echo "üîç Checking fallback expiry (14 days from first OIDC)..."
          
          if [ -n "${{ secrets.AWS_ACCESS_KEY_ID_DEV }}" ] && [ -n "${{ secrets.AWS_SECRET_ACCESS_KEY_DEV }}" ]; then
            export AWS_ACCESS_KEY_ID="${{ secrets.AWS_ACCESS_KEY_ID_DEV }}"
            export AWS_SECRET_ACCESS_KEY="${{ secrets.AWS_SECRET_ACCESS_KEY_DEV }}"
          fi
          
          export AWS_REGION=us-east-1
          
          # Try to use FIRST_OIDC_DATE from previous step if available, otherwise read from SSM
          if [ -z "${FIRST_OIDC_DATE:-}" ]; then
            FIRST_OIDC_DATE=$(aws ssm get-parameter \
              --name "/flowlogic/cicd/first-oidc-deployment-date" \
              --query "Parameter.Value" \
              --output text 2>/dev/null || echo "")
          fi
          
          if [ -z "$FIRST_OIDC_DATE" ]; then
            echo "‚ö†Ô∏è  First OIDC date not found, allowing fallback"
            echo "FALLBACK_ALLOWED=true" >> $GITHUB_ENV
          elif [ -f "scripts/check-fallback-expiry.sh" ]; then
            if ./scripts/check-fallback-expiry.sh "$FIRST_OIDC_DATE"; then
              echo "FALLBACK_ALLOWED=true" >> $GITHUB_ENV
            else
              echo "FALLBACK_ALLOWED=false" >> $GITHUB_ENV
              exit 1
            fi
          else
            echo "FALLBACK_ALLOWED=true" >> $GITHUB_ENV
          fi

      # Step 5: Configure AWS credentials (Access Keys Fallback)
      - name: Configure AWS credentials (Access Keys Fallback)
        if: steps.check-aws-creds.outputs.HAS_ACCESS_KEYS == 'true' && steps.aws-config-oidc.outcome != 'success' && steps.check-fallback-expiry.outcome == 'success'
        uses: aws-actions/configure-aws-credentials@v5
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID_DEV }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY_DEV }}
          aws-region: us-east-1
        id: aws-config-keys

      # Step 6: Send fallback metric (if used)
      - name: Send fallback metric
        if: steps.aws-config-oidc.outcome != 'success' && steps.aws-config-keys.outcome == 'success'
        run: |
          echo "‚ö†Ô∏è  Using Access Keys fallback for dev"
          if [ -f "scripts/send-fallback-metric.sh" ]; then
            ./scripts/send-fallback-metric.sh dev || true
          fi

      - name: Validate serverless configuration
        if: steps.aws-config-oidc.outcome == 'success' || steps.aws-config-keys.outcome == 'success'
        run: |
          echo "üîç Validating serverless.yml configuration..."
          if [ -f "scripts/validate-serverless-config.sh" ]; then
            ./scripts/validate-serverless-config.sh || {
              echo "‚ùå Serverless configuration validation failed"
              exit 1
            }
          else
            echo "‚ö†Ô∏è  validate-serverless-config.sh not found, skipping validation"
          fi

      - name: Run Bug Hunter (pre-deploy check)
        if: steps.aws-config-oidc.outcome == 'success' || steps.aws-config-keys.outcome == 'success'
        run: |
          echo "üîç Running Bug Hunter (fast mode)..."
          if [ -f "scripts/bug-hunter.sh" ]; then
            ./scripts/bug-hunter.sh --mode fast || {
              echo "‚ö†Ô∏è  Bug Hunter found issues, but continuing deployment"
              echo "   Review issues manually after deployment"
            }
          else
            echo "‚ö†Ô∏è  bug-hunter.sh not found, skipping Bug Hunter check"
          fi

      - name: Deploy to AWS (Dev)
        if: steps.aws-config-oidc.outcome == 'success' || steps.aws-config-keys.outcome == 'success'
        working-directory: infra/serverless
        env:
          SERVERLESS_ACCESS_KEY: ${{ secrets.SERVERLESS_ACCESS_KEY }}
        run: |
          echo "üöÄ Deploying to dev using npm scripts..."
          echo "   This will run pre-deploy checks automatically"
          npm run deploy:dev || {
            echo "‚ùå Deployment failed"
            exit 1
          }

      - name: Run post-deploy checks
        if: steps.aws-config-oidc.outcome == 'success' || steps.aws-config-keys.outcome == 'success'
        run: ./scripts/post_deploy.sh dev

  deploy-staging:
    if: github.event_name == 'workflow_dispatch' && github.event.inputs.stage == 'staging'
    name: Deploy to Staging
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
    environment:
      name: staging
      url: https://84xkp5s9q6.execute-api.us-east-1.amazonaws.com/staging/
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'
          cache: 'npm'
          cache-dependency-path: infra/serverless/package-lock.json

      - name: Install Serverless Framework
        run: npm install -g serverless@4
      
      - name: Configure Serverless Framework Access Key
        env:
          SERVERLESS_ACCESS_KEY: ${{ secrets.SERVERLESS_ACCESS_KEY }}
        run: |
          if [ -n "$SERVERLESS_ACCESS_KEY" ]; then
            echo "‚úÖ Serverless Framework Access Key found"
            export SERVERLESS_ACCESS_KEY
          else
            echo "‚ö†Ô∏è  SERVERLESS_ACCESS_KEY not found in secrets"
            echo "   Serverless Framework v4 requires an access key"
            exit 1
          fi

      - name: Install dependencies
        working-directory: infra/serverless
        run: npm ci

      - name: Build TypeScript backend
        working-directory: src/backend
        run: npm ci && npm run build

      # Step 1: Check AWS credentials configuration
      - name: Check AWS credentials configuration
        id: check-aws-creds
        run: |
          USE_OIDC="false"
          HAS_ACCESS_KEYS="false"
          
          if [ -n "${{ secrets.AWS_ROLE_ARN }}" ]; then
            USE_OIDC="true"
            echo "‚úÖ AWS_ROLE_ARN found in GitHub Environment"
          else
            echo "‚ö†Ô∏è  AWS_ROLE_ARN not found in GitHub Environment"
          fi
          
          if [ -n "${{ secrets.AWS_ACCESS_KEY_ID_STAGING }}" ] && [ -n "${{ secrets.AWS_SECRET_ACCESS_KEY_STAGING }}" ]; then
            HAS_ACCESS_KEYS="true"
            echo "‚úÖ Access Keys found (for fallback)"
          fi
          
          echo "USE_OIDC=$USE_OIDC" >> $GITHUB_OUTPUT
          echo "HAS_ACCESS_KEYS=$HAS_ACCESS_KEYS" >> $GITHUB_OUTPUT
          
          if [ "$USE_OIDC" != "true" ] && [ "$HAS_ACCESS_KEYS" != "true" ]; then
            echo "‚ùå ERROR: Neither AWS_ROLE_ARN nor Access Keys are configured!"
            exit 1
          fi

      # Step 2: Configure OIDC
      - name: Configure AWS credentials (OIDC)
        if: steps.check-aws-creds.outputs.USE_OIDC == 'true'
        uses: aws-actions/configure-aws-credentials@v5
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: us-east-1
          role-session-name: github-${{ github.run_id }}-staging
        continue-on-error: true
        id: aws-config-oidc

      # Step 3: Validate AWS credentials
      - name: Validate AWS credentials
        if: steps.aws-config-oidc.outcome == 'success'
        env:
          AWS_ROLE_ARN: ${{ secrets.AWS_ROLE_ARN }}
          ENVIRONMENT: staging
        run: |
          if [ -f "scripts/validate-aws-credentials.sh" ]; then
            ./scripts/validate-aws-credentials.sh staging
          fi

      # Step 3.5: Load SSM Parameters Early (when OIDC token is fresh)
      - name: Load SSM Parameters Early
        if: steps.aws-config-oidc.outcome == 'success'
        id: load-ssm-params
        run: |
          echo "üîç Loading SSM parameters early (OIDC token is fresh)..."
          
          # Read first OIDC deployment date from SSM Parameter Store
          FIRST_OIDC_DATE=$(aws ssm get-parameter \
            --name "/flowlogic/cicd/first-oidc-deployment-date" \
            --query "Parameter.Value" \
            --output text 2>/dev/null || echo "")
          
          if [ -n "$FIRST_OIDC_DATE" ]; then
            echo "‚úÖ First OIDC date loaded: $FIRST_OIDC_DATE"
            echo "FIRST_OIDC_DATE=$FIRST_OIDC_DATE" >> $GITHUB_ENV
          else
            echo "‚ö†Ô∏è  First OIDC date not found in SSM Parameter Store"
            echo "FIRST_OIDC_DATE=" >> $GITHUB_ENV
          fi
          
          # Load any other SSM parameters needed for deployment
          # Add more parameters here as needed
          echo "‚úÖ SSM parameters loaded successfully"

      # Step 4: Check fallback expiry (if OIDC failed)
      - name: Check fallback expiry
        if: steps.aws-config-oidc.outcome != 'success' && steps.check-aws-creds.outputs.HAS_ACCESS_KEYS == 'true'
        id: check-fallback-expiry
        run: |
          echo "üîç Checking fallback expiry (14 days from first OIDC)..."
          
          if [ -n "${{ secrets.AWS_ACCESS_KEY_ID_STAGING }}" ] && [ -n "${{ secrets.AWS_SECRET_ACCESS_KEY_STAGING }}" ]; then
            export AWS_ACCESS_KEY_ID="${{ secrets.AWS_ACCESS_KEY_ID_STAGING }}"
            export AWS_SECRET_ACCESS_KEY="${{ secrets.AWS_SECRET_ACCESS_KEY_STAGING }}"
          fi
          
          export AWS_REGION=us-east-1
          
          # Try to use FIRST_OIDC_DATE from previous step if available, otherwise read from SSM
          if [ -z "${FIRST_OIDC_DATE:-}" ]; then
            FIRST_OIDC_DATE=$(aws ssm get-parameter \
              --name "/flowlogic/cicd/first-oidc-deployment-date" \
              --query "Parameter.Value" \
              --output text 2>/dev/null || echo "")
          fi
          
          if [ -z "$FIRST_OIDC_DATE" ]; then
            echo "‚ö†Ô∏è  First OIDC date not found, allowing fallback"
            echo "FALLBACK_ALLOWED=true" >> $GITHUB_ENV
          elif [ -f "scripts/check-fallback-expiry.sh" ]; then
            if ./scripts/check-fallback-expiry.sh "$FIRST_OIDC_DATE"; then
              echo "FALLBACK_ALLOWED=true" >> $GITHUB_ENV
            else
              echo "FALLBACK_ALLOWED=false" >> $GITHUB_ENV
              exit 1
            fi
          else
            echo "FALLBACK_ALLOWED=true" >> $GITHUB_ENV
          fi

      # Step 5: Configure AWS credentials (Access Keys Fallback)
      - name: Configure AWS credentials (Access Keys Fallback)
        if: steps.check-aws-creds.outputs.HAS_ACCESS_KEYS == 'true' && steps.aws-config-oidc.outcome != 'success' && steps.check-fallback-expiry.outcome == 'success'
        uses: aws-actions/configure-aws-credentials@v5
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID_STAGING }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY_STAGING }}
          aws-region: us-east-1
        id: aws-config-keys

      # Step 6: Send fallback metric (if used)
      - name: Send fallback metric
        if: steps.aws-config-oidc.outcome != 'success' && steps.aws-config-keys.outcome == 'success'
        run: |
          echo "‚ö†Ô∏è  Using Access Keys fallback for staging"
          if [ -f "scripts/send-fallback-metric.sh" ]; then
            ./scripts/send-fallback-metric.sh staging || true
          fi

      - name: Validate serverless configuration
        if: steps.aws-config-oidc.outcome == 'success' || steps.aws-config-keys.outcome == 'success'
        run: |
          echo "üîç Validating serverless.yml configuration..."
          if [ -f "scripts/validate-serverless-config.sh" ]; then
            ./scripts/validate-serverless-config.sh || {
              echo "‚ùå Serverless configuration validation failed"
              exit 1
            }
          else
            echo "‚ö†Ô∏è  validate-serverless-config.sh not found, skipping validation"
          fi

      - name: Run Bug Hunter (pre-deploy check)
        if: steps.aws-config-oidc.outcome == 'success' || steps.aws-config-keys.outcome == 'success'
        run: |
          echo "üîç Running Bug Hunter (fast mode)..."
          if [ -f "scripts/bug-hunter.sh" ]; then
            ./scripts/bug-hunter.sh --mode fast || {
              echo "‚ö†Ô∏è  Bug Hunter found issues, but continuing deployment"
              echo "   Review issues manually after deployment"
            }
          else
            echo "‚ö†Ô∏è  bug-hunter.sh not found, skipping Bug Hunter check"
          fi

      - name: Deploy to AWS (Staging)
        if: steps.aws-config-oidc.outcome == 'success' || steps.aws-config-keys.outcome == 'success'
        working-directory: infra/serverless
        env:
          SERVERLESS_ACCESS_KEY: ${{ secrets.SERVERLESS_ACCESS_KEY }}
        run: |
          echo "üöÄ Deploying to staging using npm scripts..."
          echo "   This will run pre-deploy checks automatically"
          npm run deploy:staging || {
            echo "‚ùå Deployment failed"
            echo ""
            echo "üîç Debug: Post-failure diagnostics..."
            echo "  AWS identity:"
            aws sts get-caller-identity 2>&1 || echo "    ‚ö†Ô∏è  Failed"
            echo "  Stack status:"
            aws cloudformation describe-stacks --stack-name flowlogic-backend-staging --region us-east-1 --query 'Stacks[0].StackStatus' --output text 2>&1 || echo "    ‚ö†Ô∏è  Stack not found"
            exit 1
          }
          echo "Step 2: Determine stack name from service name"
          SERVICE_NAME=$(grep "^service:" serverless.yml | awk '{print $2}' | tr -d '"')
          STACK_NAME="${SERVICE_NAME}-staging"
          echo "Stack name: $STACK_NAME"
          echo "Step 3: Check stack status and handle DELETE_FAILED if needed"
          STACK_STATUS=$(aws cloudformation describe-stacks --stack-name "$STACK_NAME" --query 'Stacks[0].StackStatus' --output text 2>&1 || echo "DOES_NOT_EXIST")
          if [ "$STACK_STATUS" = "DELETE_FAILED" ]; then
            echo "‚ö†Ô∏è  Stack in DELETE_FAILED state, force deleting..."
            aws cloudformation delete-stack --stack-name "$STACK_NAME" --deletion-mode FORCE_DELETE_STACK 2>&1 || true
            echo "Waiting for stack deletion..."
            aws cloudformation wait stack-delete-complete --stack-name "$STACK_NAME" 2>&1 || echo "Stack deletion in progress or completed"
            STACK_STATUS="DOES_NOT_EXIST"
          fi
          echo "Step 4: Deploy stack"
          if [ "$STACK_STATUS" = "DOES_NOT_EXIST" ] || aws cloudformation describe-stacks --stack-name "$STACK_NAME" 2>&1 | grep -q "does not exist"; then
            echo "Stack does not exist, creating new stack..."
            if [ ! -f .serverless/cloudformation-template-create-stack.json ]; then
              echo "‚ùå ERROR: cloudformation-template-create-stack.json not found!"
              exit 1
            fi
            echo "Creating initial stack with deployment bucket..."
            aws cloudformation create-stack \
              --stack-name "$STACK_NAME" \
              --template-body file://.serverless/cloudformation-template-create-stack.json \
              --capabilities CAPABILITY_NAMED_IAM CAPABILITY_AUTO_EXPAND || {
              echo "=== DEPLOYMENT FAILED ==="
              exit 1
            }
            echo "Waiting for initial stack creation..."
            aws cloudformation wait stack-create-complete --stack-name "$STACK_NAME" || {
              echo "‚ùå Initial stack creation failed!"
              aws cloudformation describe-stack-events --stack-name "$STACK_NAME" --max-items 10 --query 'StackEvents[?ResourceStatus==`CREATE_FAILED`].{LogicalResourceId:LogicalResourceId,Reason:ResourceStatusReason}' --output json 2>&1 | jq '.'
              exit 1
            }
            echo "‚úÖ Initial stack created successfully!"
            echo "Step 5: Update stack with all resources..."
            if [ ! -f .serverless/cloudformation-template-update-stack.json ]; then
              echo "‚ùå ERROR: cloudformation-template-update-stack.json not found!"
              exit 1
            fi
            aws cloudformation update-stack \
              --stack-name "$STACK_NAME" \
              --template-body file://.serverless/cloudformation-template-update-stack.json \
              --capabilities CAPABILITY_NAMED_IAM CAPABILITY_AUTO_EXPAND || {
              echo "‚ö†Ô∏è  Update stack command failed, checking if no changes needed..."
              if aws cloudformation describe-stacks --stack-name "$STACK_NAME" 2>&1 | grep -q "UPDATE_COMPLETE\|CREATE_COMPLETE"; then
                echo "‚úÖ Stack is already complete"
              else
                exit 1
              fi
            }
            echo "Waiting for stack update with all resources..."
            aws cloudformation wait stack-update-complete --stack-name "$STACK_NAME" 2>&1 || {
              echo "‚ö†Ô∏è  Update may have completed or no changes needed"
              aws cloudformation describe-stacks --stack-name "$STACK_NAME" --query 'Stacks[0].StackStatus' --output text 2>&1
            }
            echo "‚úÖ Stack fully deployed with all resources!"
          else
            echo "Stack exists, updating..."
            if [ ! -f .serverless/cloudformation-template-update-stack.json ]; then
              echo "‚ùå ERROR: cloudformation-template-update-stack.json not found!"
              exit 1
            fi
            UPDATE_OUTPUT=$(aws cloudformation update-stack \
              --stack-name "$STACK_NAME" \
              --template-body file://.serverless/cloudformation-template-update-stack.json \
              --capabilities CAPABILITY_NAMED_IAM CAPABILITY_AUTO_EXPAND 2>&1)
            if echo "$UPDATE_OUTPUT" | grep -q "No updates are to be performed"; then
              echo "No updates needed"
            elif echo "$UPDATE_OUTPUT" | grep -q "StackId"; then
              echo "Update initiated, waiting for completion..."
              aws cloudformation wait stack-update-complete --stack-name "$STACK_NAME" || {
                echo "‚ö†Ô∏è  Stack update may have failed or no updates needed"
                aws cloudformation describe-stack-events --stack-name "$STACK_NAME" --max-items 5 --query 'StackEvents[*].{Status:ResourceStatus,Reason:ResourceStatusReason}' --output json 2>&1 | jq '.' | head -20
              }
              echo "‚úÖ Stack updated successfully!"
            else
              echo "Update output: $UPDATE_OUTPUT"
              echo "‚úÖ Update initiated or no changes needed"
            fi
          fi

      - name: Run post-deploy checks
        if: steps.aws-config-oidc.outcome == 'success' || steps.aws-config-keys.outcome == 'success'
        run: ./scripts/post_deploy.sh staging

  deploy-production:
    if: github.event_name == 'workflow_dispatch' && github.event.inputs.stage == 'production'
    name: Deploy to Production
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
    environment:
      name: production
      url: https://84xkp5s9q6.execute-api.us-east-1.amazonaws.com/production/
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'
          cache: 'npm'
          cache-dependency-path: infra/serverless/package-lock.json

      - name: Install Serverless Framework
        run: npm install -g serverless@4
      
      - name: Configure Serverless Framework Access Key
        env:
          SERVERLESS_ACCESS_KEY: ${{ secrets.SERVERLESS_ACCESS_KEY }}
        run: |
          if [ -n "$SERVERLESS_ACCESS_KEY" ]; then
            echo "‚úÖ Serverless Framework Access Key found"
            export SERVERLESS_ACCESS_KEY
          else
            echo "‚ö†Ô∏è  SERVERLESS_ACCESS_KEY not found in secrets"
            echo "   Serverless Framework v4 requires an access key"
            exit 1
          fi

      - name: Install dependencies
        working-directory: infra/serverless
        run: npm ci

      - name: Build TypeScript backend
        working-directory: src/backend
        run: npm ci && npm run build

      # Step 1: Check AWS credentials configuration
      - name: Check AWS credentials configuration
        id: check-aws-creds
        run: |
          USE_OIDC="false"
          HAS_ACCESS_KEYS="false"
          
          if [ -n "${{ secrets.AWS_ROLE_ARN }}" ]; then
            USE_OIDC="true"
            echo "‚úÖ AWS_ROLE_ARN found in GitHub Environment"
          else
            echo "‚ö†Ô∏è  AWS_ROLE_ARN not found in GitHub Environment"
          fi
          
          if [ -n "${{ secrets.AWS_ACCESS_KEY_ID_PROD }}" ] && [ -n "${{ secrets.AWS_SECRET_ACCESS_KEY_PROD }}" ]; then
            HAS_ACCESS_KEYS="true"
            echo "‚úÖ Access Keys found (for fallback)"
          fi
          
          echo "USE_OIDC=$USE_OIDC" >> $GITHUB_OUTPUT
          echo "HAS_ACCESS_KEYS=$HAS_ACCESS_KEYS" >> $GITHUB_OUTPUT
          
          if [ "$USE_OIDC" != "true" ] && [ "$HAS_ACCESS_KEYS" != "true" ]; then
            echo "‚ùå ERROR: Neither AWS_ROLE_ARN nor Access Keys are configured!"
            exit 1
          fi

      # Step 2: Configure OIDC
      - name: Configure AWS credentials (OIDC)
        if: steps.check-aws-creds.outputs.USE_OIDC == 'true'
        uses: aws-actions/configure-aws-credentials@v5
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: us-east-1
          role-session-name: github-${{ github.run_id }}-production
        continue-on-error: true
        id: aws-config-oidc

      # Step 3: Validate AWS credentials
      - name: Validate AWS credentials
        if: steps.aws-config-oidc.outcome == 'success'
        env:
          AWS_ROLE_ARN: ${{ secrets.AWS_ROLE_ARN }}
          ENVIRONMENT: production
        run: |
          if [ -f "scripts/validate-aws-credentials.sh" ]; then
            ./scripts/validate-aws-credentials.sh production
          fi

      # Step 3.5: Load SSM Parameters Early (when OIDC token is fresh)
      - name: Load SSM Parameters Early
        if: steps.aws-config-oidc.outcome == 'success'
        id: load-ssm-params
        run: |
          echo "üîç Loading SSM parameters early (OIDC token is fresh)..."
          
          # Read first OIDC deployment date from SSM Parameter Store
          FIRST_OIDC_DATE=$(aws ssm get-parameter \
            --name "/flowlogic/cicd/first-oidc-deployment-date" \
            --query "Parameter.Value" \
            --output text 2>/dev/null || echo "")
          
          if [ -n "$FIRST_OIDC_DATE" ]; then
            echo "‚úÖ First OIDC date loaded: $FIRST_OIDC_DATE"
            echo "FIRST_OIDC_DATE=$FIRST_OIDC_DATE" >> $GITHUB_ENV
          else
            echo "‚ö†Ô∏è  First OIDC date not found in SSM Parameter Store"
            echo "FIRST_OIDC_DATE=" >> $GITHUB_ENV
          fi
          
          # Load any other SSM parameters needed for deployment
          # Add more parameters here as needed
          echo "‚úÖ SSM parameters loaded successfully"

      # Step 4: Load secrets from AWS Secrets Manager (production)
      - name: Load secrets from AWS Secrets Manager
        if: steps.aws-config-oidc.outcome == 'success'
        run: |
          echo "üîç Loading secrets from AWS Secrets Manager for production..."
          
          # Load secrets using read-secrets-manager.sh
          if [ -f "scripts/read-secrets-manager.sh" ]; then
            # Load payment secrets
            if ./scripts/read-secrets-manager.sh --category payment --export > /tmp/secrets-payment.sh 2>/dev/null; then
              source /tmp/secrets-payment.sh
              echo "‚úÖ Payment secrets loaded"
            fi
            
            # Load database secrets
            if ./scripts/read-secrets-manager.sh --category database --export > /tmp/secrets-database.sh 2>/dev/null; then
              source /tmp/secrets-database.sh
              echo "‚úÖ Database secrets loaded"
            fi
            
            # Load encryption secrets
            if ./scripts/read-secrets-manager.sh --category encryption --export > /tmp/secrets-encryption.sh 2>/dev/null; then
              source /tmp/secrets-encryption.sh
              echo "‚úÖ Encryption secrets loaded"
            fi
            
            # Load authentication secrets
            if ./scripts/read-secrets-manager.sh --category authentication --export > /tmp/secrets-auth.sh 2>/dev/null; then
              source /tmp/secrets-auth.sh
              echo "‚úÖ Authentication secrets loaded"
            fi
          else
            echo "‚ö†Ô∏è  read-secrets-manager.sh not found, skipping secrets loading"
          fi

      # Step 5: Check fallback expiry (if OIDC failed)
      - name: Check fallback expiry
        if: steps.aws-config-oidc.outcome != 'success' && steps.check-aws-creds.outputs.HAS_ACCESS_KEYS == 'true'
        id: check-fallback-expiry
        run: |
          echo "üîç Checking fallback expiry (14 days from first OIDC)..."
          
          if [ -n "${{ secrets.AWS_ACCESS_KEY_ID_PROD }}" ] && [ -n "${{ secrets.AWS_SECRET_ACCESS_KEY_PROD }}" ]; then
            export AWS_ACCESS_KEY_ID="${{ secrets.AWS_ACCESS_KEY_ID_PROD }}"
            export AWS_SECRET_ACCESS_KEY="${{ secrets.AWS_SECRET_ACCESS_KEY_PROD }}"
          fi
          
          export AWS_REGION=us-east-1
          
          # Try to use FIRST_OIDC_DATE from previous step if available, otherwise read from SSM
          if [ -z "${FIRST_OIDC_DATE:-}" ]; then
            FIRST_OIDC_DATE=$(aws ssm get-parameter \
              --name "/flowlogic/cicd/first-oidc-deployment-date" \
              --query "Parameter.Value" \
              --output text 2>/dev/null || echo "")
          fi
          
          if [ -z "$FIRST_OIDC_DATE" ]; then
            echo "‚ö†Ô∏è  First OIDC date not found, allowing fallback"
            echo "FALLBACK_ALLOWED=true" >> $GITHUB_ENV
          elif [ -f "scripts/check-fallback-expiry.sh" ]; then
            if ./scripts/check-fallback-expiry.sh "$FIRST_OIDC_DATE"; then
              echo "FALLBACK_ALLOWED=true" >> $GITHUB_ENV
            else
              echo "FALLBACK_ALLOWED=false" >> $GITHUB_ENV
              exit 1
            fi
          else
            echo "FALLBACK_ALLOWED=true" >> $GITHUB_ENV
          fi

      # Step 6: Configure AWS credentials (Access Keys Fallback)
      - name: Configure AWS credentials (Access Keys Fallback)
        if: steps.check-aws-creds.outputs.HAS_ACCESS_KEYS == 'true' && steps.aws-config-oidc.outcome != 'success' && steps.check-fallback-expiry.outcome == 'success'
        uses: aws-actions/configure-aws-credentials@v5
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID_PROD }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY_PROD }}
          aws-region: us-east-1
        id: aws-config-keys

      # Step 7: Send fallback metric (if used)
      - name: Send fallback metric
        if: steps.aws-config-oidc.outcome != 'success' && steps.aws-config-keys.outcome == 'success'
        run: |
          echo "‚ö†Ô∏è  Using Access Keys fallback for production"
          if [ -f "scripts/send-fallback-metric.sh" ]; then
            ./scripts/send-fallback-metric.sh production || true
          fi

      - name: Validate serverless configuration
        if: steps.aws-config-oidc.outcome == 'success' || steps.aws-config-keys.outcome == 'success'
        run: |
          echo "üîç Validating serverless.yml configuration..."
          if [ -f "scripts/validate-serverless-config.sh" ]; then
            ./scripts/validate-serverless-config.sh || {
              echo "‚ùå Serverless configuration validation failed"
              exit 1
            }
          else
            echo "‚ö†Ô∏è  validate-serverless-config.sh not found, skipping validation"
          fi

      - name: Run Bug Hunter (pre-deploy check)
        if: steps.aws-config-oidc.outcome == 'success' || steps.aws-config-keys.outcome == 'success'
        run: |
          echo "üîç Running Bug Hunter (fast mode)..."
          if [ -f "scripts/bug-hunter.sh" ]; then
            ./scripts/bug-hunter.sh --mode fast || {
              echo "‚ö†Ô∏è  Bug Hunter found issues, but continuing deployment"
              echo "   Review issues manually after deployment"
            }
          else
            echo "‚ö†Ô∏è  bug-hunter.sh not found, skipping Bug Hunter check"
          fi

      - name: Deploy to AWS (Production)
        if: steps.aws-config-oidc.outcome == 'success' || steps.aws-config-keys.outcome == 'success'
        working-directory: infra/serverless
        env:
          SERVERLESS_ACCESS_KEY: ${{ secrets.SERVERLESS_ACCESS_KEY }}
        run: |
          echo "üöÄ Deploying to production using npm scripts..."
          echo "   This will run pre-deploy checks automatically"
          npm run deploy:prod || {
            echo "‚ùå Deployment failed"
            echo ""
            echo "üîç Debug: Post-failure diagnostics..."
            echo "  AWS identity:"
            aws sts get-caller-identity 2>&1 || echo "    ‚ö†Ô∏è  Failed"
            echo "  Stack status:"
            aws cloudformation describe-stacks --stack-name flowlogic-backend-production --region us-east-1 --query 'Stacks[0].StackStatus' --output text 2>&1 || echo "    ‚ö†Ô∏è  Stack not found"
            exit 1
          }

      - name: Run post-deploy checks
        if: steps.aws-config-oidc.outcome == 'success' || steps.aws-config-keys.outcome == 'success'
        run: ./scripts/post_deploy.sh production

